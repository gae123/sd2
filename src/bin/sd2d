#!/usr/bin/env python
#############################################################################
# Copyright (c) 2017 SiteWare Corp. All right reserved
#############################################################################

import argparse
import fcntl
import logging
import os
import subprocess
import sys
import time
import datetime
import sd2

ON_POSIX = 'posix' in sys.builtin_module_names

g_workspaces = []
g_args = None

class Workspace(object):
    def __init__(self, node):
        self._node = node

    def get_targets(self):
        hosts = self._node.get('targets', [])
        hosts = [x for x in hosts if sd2.myhosts.is_enabled(x['name'])]
        for host in hosts:
            assert 'name' in host
        return hosts

def slash_ending(path):
    if not path.endswith(os.path.sep):
        path += os.path.sep
    return path

################################################################################

# def resync_reg_exp_match(root, apath, ipath):
#     if not apath.startswith(root):
#         return False
#     rpath = apath[len(root)-1:]
#     aipath = ipath.split('/')
#     arpath = rpath.split('/')
#     while len(aipath) and len(arpath):
#         if aipath[0] == arpath[0]:
#             aipath.pop(0)
#             arpath.pop(0)
#             continue
#         if ipath[0] == '*':
#             aipath.pop(0)
#             arpath.pop(0)
#             continue
#         if aipath[0] == '**':
#             while len(aipath) and len(arpath) and

def convert_rsync_to_regex(path):
    rr = path
    if not rr.startswith('/'):
        rr = '**/' + rr
    rr = rr.replace('.', '\\.')
    rr = rr.replace('**', '__EVERYTHING__')
    rr = rr.replace('*', '__ONELEVEL__')
    rr = rr.replace('__EVERYTHING__', '.*')
    rr = rr.replace('__ONELEVEL__', '[^/]*')
    return rr
    

def workspace_instance_has_path(wi, apath):
    import re
    full_path = os.path.join(wi['source_root'], wi.get('source', ''))
    if not full_path.endswith(os.path.sep):
        full_path += os.path.sep
    if apath.startswith(full_path):
        logging.debug("%s might belong to %s", apath, wi['name'])
        for paths in wi.get('paths'):
            if paths.get('include'):
                found = False
                for ipath in paths.get('include'):
                    logging.debug("CNS:INCL:%s (%s) %s", ipath, apath, full_path)
                    ripath = convert_rsync_to_regex(ipath)
                    if (re.match(r'^' + wi['source_root'].rstrip('/') + ripath + r'$', apath)):
                        logging.debug("FOUND:INCL:%s (%s)", ipath, apath)
                        found = True
                        break
                if not found:
                    return False
                if found:
                    return True
            if paths.get('exclude'):
                for epath in paths.get('exclude'):
                    logging.debug("CNS:EXCL:%s (%s)", epath, apath)
                    repath = convert_rsync_to_regex(epath)
                    if (re.match(r'^' + wi['source_root'].rstrip('/') + repath + r'$', apath)):
                            logging.debug("EXCL %s from %s", apath, wi['name'])
                            return False
        return True
    return False


def workspace_instance_sync(wi):
    for host in Workspace(wi).get_targets():
        if g_args.hosts and not host['name'] in g_args.hosts:
            continue
        host['needsync'] = 1


def deal_with_changed_file(wi, fpath):
    if workspace_instance_has_path(wi, fpath):
        logging.debug("FOUND: wsi %s has path %s", wi['name'], fpath)
        if os.path.isfile(fpath):
            for target in Workspace(wi).get_targets():
                if g_args.hosts and not target['name'] in g_args.hosts:
                    continue
                cmd = "scp -p {} {}:{}".format(
                    fpath,
                    target['name'],
                    fpath.replace(os.environ.get('HOME'), '~'))
                if g_args.dryrun:
                    cmd = 'echo ' + cmd
                logging.info(cmd)
                subprocess.Popen(cmd, shell=True)
        else:
            workspace_instance_sync(wi)

################################################################################

# For rsync --exclude and --include are followed in order. If something is
def get_rsync_cmd(ws, host):
    cmd = ['rsync',
           '-rlptgoOzv'
           ]
    if g_args.dryrun:
        cmd.append('--dry-run')
    for paths in ws.get('paths'):
        if paths.get('include'):
            for path in paths.get('include'):
                cmd.append('--include=' + path)
        elif paths.get('exclude'):
            for path in paths.get('exclude'):
                cmd.append('--exclude=' + path)
    if ws.get('delete'):
        cmd.append('--delete')
        cmd.append('--force-delete')
    if g_args.usessh:
        cmd.append('-e')
        cmd.append('ssh')
    path = os.path.join(ws['source_root'], ws.get("source", ""))
    cmd.append(slash_ending(path))
    dest_root = ws.get('dest_root', ws['source_root']).replace(os.environ.get('HOME'), '~')
    cmd.append("{}:{}".format(host['name'],
            slash_ending(os.path.join(dest_root, ws.get("source", "")))))
    return cmd


def _glob_to_regex(ss):
    rr = ss.replace('.', '\\.')
    rr = rr.replace('*', '.*')
    return rr

def kill_subprocess_process(proc, label=''):
    try:
        if not proc:
            return
        proc.poll()
        if proc.returncode is not None:
            return
        #proc.kill()
        os.system("sudo kill {}".format(proc.pid))
    except:
        logging.warning("KIILL:FAIL %s", label)
        pass

# fswatch includes everything in --include if exists. Then checks --exclude
# Order does not matter
# http://emcrisostomo.github.io/fswatch/doc/1.4.3/pdf/fswatch.pdf
class FSWatcher(object):
    def __init__(self, host):
        logging.debug("FSW:EE")
        assert host == '' or isinstance(host, list)
        for wi in g_workspaces:
            cmd = ['fswatch',
                   '--latency', '0.1',
                   '--recursive',
                   # "--exclude='.*\.pyc$'",
                   # "--exclude='.*\.swp$'",
                   # "--exclude='.*\.swpx$'",
                   # "--exclude='\.idea/.*'",
                   # "--exclude='\.git/.*'"
                   ]
            paths_to_watch = []
            if not host or set(host).intersection(
                    [x['name'] for x in Workspace(wi).get_targets()]):
                for paths in wi.get('paths'):
                    if paths.get('include'):
                        for path in paths.get('include'):
                            cmd.append(
                                "--include='{}'".format(convert_rsync_to_regex(path)))
                    elif paths.get('exclude'):
                        for path in paths.get('exclude'):
                            cmd.append(
                                "--exclude='{}'".format(convert_rsync_to_regex(path)))

                paths_to_watch.append(
                    os.path.join(wi['source_root'], wi.get('source', '')))
            for pp in paths_to_watch:
                if not pp.endswith(os.path.sep):
                    pp += '/'
                cmd.append(pp)
            strcmd = " ".join(cmd)
            logging.info("%s %s", wi['name'], strcmd)
            wi['fswatchproc'] = subprocess.Popen(
                strcmd,
                shell=True,
                bufsize=1,  # line buffered
                stdout=subprocess.PIPE,
                # stderr=subprocess.PIPE,
                close_fds=ON_POSIX
            )
            fl = fcntl.fcntl(wi['fswatchproc'].stdout, fcntl.F_GETFL)
            fcntl.fcntl(wi['fswatchproc'].stdout, fcntl.F_SETFL,
                        fl | os.O_NONBLOCK)
        logging.debug("FSW:LL")

    def poll(self):
        for ws in g_workspaces:
            proc = ws['fswatchproc']
            try:
                line = proc.stdout.readline().strip()
            except IOError:
                continue
            logging.debug('CONS %s %s', ws['name'], line)
            deal_with_changed_file(ws, line)

    def shutdown(self):
        for wi in g_workspaces:
            proc = wi['fswatchproc']
            kill_subprocess_process(proc, "FSWATH {}".format(wi['name']))


def parse_arguments():
    global g_args
    parser = argparse.ArgumentParser()
    parser.add_argument('--usessh', '-s', action="store_false",
                                    default=True,
                                    help="use_ssh")
    parser.add_argument('--version', '-v', action="store_true", default=False)
    parser.add_argument('--level', '-l', default='error',
                        help="Pass debug,info or error to set the debug level")
    parser.add_argument('--dryrun', '-n', action="store_true", default=False)
    parser.add_argument("hosts", nargs="*", help="host to sync, leave it empty to include all hosts", default='')
    g_args = parser.parse_args(sys.argv[1:])

    logging.getLogger().setLevel({
        'info': logging.INFO,
        'debug': logging.DEBUG,
        'error': logging.ERROR,
        'warning': logging.WARNING
    }[g_args.level])

    if g_args.version:
        import sd2
        print sd2.__version__
        sys.exit(0)

class SSHConnections(object):
    hosts_to_ssh = None
    def __init__(self):
        self.hosts_to_ssh = {}
        for host in sd2.myhosts.hosts:
            if sd2.myhosts.is_disabled(host['name']):
                continue
            if not g_args.hosts or host['name'] in g_args.hosts:
                host['needsync'] = 1
                self.hosts_to_ssh[host['name']] = {
                    'name': host['name'],
                    'sshproc': None,
                    'sshcmd': 'sudo ssh -F ~/.ssh/config -T ' + host[
                        'name'] + '-ports'
                }

    def poll(self):
        for host in self.hosts_to_ssh.values():
            if host['sshproc']:
                host['sshproc'].poll()
                while (True):
                    try:
                        line = host['sshproc'].stderr.readline()
                    except IOError:
                        break
                    if line:
                        sys.stdout.write("SSH {}: {}".format(
                            host['name'], line))
                    else:
                        break
            # logging.info("%s %s",host, host['sshproc'].returncode if host['sshproc'] else '???')
            if host['sshproc'] is None or host['sshproc'].returncode != None:
                if host['sshproc'] and host['sshproc'].returncode != None:
                    logging.info("SSH:RET:CODE %s=%s",
                                 host['sshcmd'],
                                 host['sshproc'].returncode)
                    host['sshproc'] = None
                logging.info("SSH:START %s", host['sshcmd'])
                try:
                    host['sshproc'] = subprocess.Popen(
                        host['sshcmd'],
                        shell=True,
                        stdin=subprocess.PIPE,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        close_fds=ON_POSIX)

                except Exception as ex:
                    logging.warning("SSH:START:EXC: %s", ex)
                fl = fcntl.fcntl(host['sshproc'].stderr, fcntl.F_GETFL)
                fcntl.fcntl(host['sshproc'].stderr, fcntl.F_SETFL,
                            fl | os.O_NONBLOCK)

    def shutdown(self):
        for host in self.hosts_to_ssh.values():
            proc = host['sshproc']
            kill_subprocess_process(proc, "SSH {}".format(host['name']))


class RsyncConnections(object):

    def handle_host(self, wsi, host):
        if g_args.hosts and not host['name'] in g_args.hosts:
            return
        proc = host.get('rsyncproc')
        if proc:
            proc.poll()
            while (True):
                try:
                    line = proc.stdout.readline()
                except IOError:
                    break
                if line:
                    sys.stdout.write("RSYNC {} - {}: {}".format(
                        wsi['name'], host['name'], line))
                else:
                    break
            if proc.returncode is None:
                # logging.debug("SKIP:SYNC %s:%s", wsi['name'], host['name'])
                return
            else:
                logging.info("RET:CODE %s:%s=%s", wsi['name'],
                             host['name'],
                             proc.returncode)
                host['rsyncproc'] = None
                host['lastsync'] = datetime.datetime.now()

        # Every 15 minutes rsync
        if (host.get('lastsync') and
                    (datetime.datetime.now() - host[
                        'lastsync']).seconds > 15 * 60 * 60):
            host['needsync'] = 1
        if host.get('needsync') == 0:
            return
        cmd = get_rsync_cmd(wsi, host)
        logging.info("RSYNC {}:{} {}".format(wsi['name'],
                                             host['name'], " ".join(cmd)))
        host['rsyncproc'] = subprocess.Popen(cmd,
                                             stdout=subprocess.PIPE,
                                             stderr=subprocess.STDOUT,
                                             close_fds=ON_POSIX)
        fl = fcntl.fcntl(host['rsyncproc'].stdout, fcntl.F_GETFL)
        fcntl.fcntl(host['rsyncproc'].stdout, fcntl.F_SETFL,
                    fl | os.O_NONBLOCK)
        host['needsync'] = 0

    def poll(self):
        for wsi in g_workspaces:
            for host in Workspace(wsi).get_targets():
                self.handle_host(wsi, host)

    def shutdown(self):
        for wsi in g_workspaces:
            for host in Workspace(wsi).get_targets():
                proc = host.get('rsyncproc')
                kill_subprocess_process(
                    proc,
                    "FSWATH {} {}".format(host['name'], wsi['name']))


class RestartEcxeption(Exception):
    pass

def init():
    rr = os.system("sd2init")
    assert not rr
    logging.info("SD2INIT")
    global g_workspaces
    config_dct = sd2.read_config()
    sd2.myhosts.init(config_dct)
    g_workspaces = config_dct['workspaces']
    # Normalize that host can be just a string
    for ws in g_workspaces:
        hosts = ws.get('targets', [])
        for ii, host in enumerate(hosts):
            if isinstance(host, basestring):
                host = {'name': host}
                hosts[ii] = host
    return config_dct


def main():
    ssh_connections = fswatchers = rsyncers = None
    try:
        config_dct = init()
        ssh_connections = SSHConnections()
        fswatchers = FSWatcher(g_args.hosts)
        rsyncers = RsyncConnections()
        while True:
            if sd2.has_timestamp_changed(config_dct):
                raise RestartEcxeption()
            ssh_connections.poll()
            fswatchers.poll()
            rsyncers.poll()
            time.sleep(.1)
    finally:
        if ssh_connections:
            ssh_connections.shutdown()
        if fswatchers:
            fswatchers.shutdown()
        if rsyncers:
            rsyncers.shutdown()



parse_arguments()
while True:
    try:
        main()
    except RestartEcxeption:
        continue




